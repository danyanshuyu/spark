; generated by ARM C/C++ Compiler, 4.1 [Build 567]
; commandline ArmCC [--list --debug -c --asm --interleave -omain.o --asm_dir=.\ --list_dir=.\ --depend=main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I"E:\Program Files\Keil4\ARM\INC" -I"E:\Program Files\Keil4\ARM\INC\ST\STM32F10x" -D__MICROLIB --omf_browse=main.crf User\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  EXTI_Configuration PROC
;;;169    *******************************************************************************/
;;;170    void EXTI_Configuration()
000000  b51c              PUSH     {r2-r4,lr}
;;;171    {
;;;172    	EXTI_InitTypeDef EXTI_InitStructure;
;;;173    	ErrorStatus HSEStartUpStatus;
;;;174    
;;;175    	//GPIOG5作为外部中断线			   
;;;176    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOG,GPIO_PinSource5);
000002  2105              MOVS     r1,#5
000004  2006              MOVS     r0,#6
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;177    	//配置触发方式
;;;178    	EXTI_InitStructure.EXTI_Line = EXTI_Line1;
00000a  2002              MOVS     r0,#2
00000c  9000              STR      r0,[sp,#0]
;;;179    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00000e  2000              MOVS     r0,#0
000010  f88d0004          STRB     r0,[sp,#4]
;;;180    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //下降沿触发
000014  200c              MOVS     r0,#0xc
000016  f88d0005          STRB     r0,[sp,#5]
;;;181    	EXTI_InitStructure.EXTI_LineCmd = ENABLE; 			   //中断线使能
00001a  2001              MOVS     r0,#1
00001c  f88d0006          STRB     r0,[sp,#6]
;;;182    	EXTI_Init(&EXTI_InitStructure); 					   //初始化中断
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       EXTI_Init
;;;183    	//EXTI_Line1中断允许 
;;;184    	EXTI_GenerateSWInterrupt(EXTI_Line1); 
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       EXTI_GenerateSWInterrupt
;;;185    
;;;186    
;;;187    	//GPIOG3作为外部中断线
;;;188    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOG,GPIO_PinSource3);
00002c  2103              MOVS     r1,#3
00002e  2006              MOVS     r0,#6
000030  f7fffffe          BL       GPIO_EXTILineConfig
;;;189    	//配置触发方式
;;;190    	EXTI_InitStructure.EXTI_Line = EXTI_Line0;
000034  2001              MOVS     r0,#1
000036  9000              STR      r0,[sp,#0]
;;;191    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000038  2000              MOVS     r0,#0
00003a  f88d0004          STRB     r0,[sp,#4]
;;;192    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //下降沿触发
00003e  200c              MOVS     r0,#0xc
000040  f88d0005          STRB     r0,[sp,#5]
;;;193    	EXTI_InitStructure.EXTI_LineCmd = ENABLE; 			   //中断线使能
000044  2001              MOVS     r0,#1
000046  f88d0006          STRB     r0,[sp,#6]
;;;194    	EXTI_Init(&EXTI_InitStructure); 					   //初始化中断
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       EXTI_Init
;;;195    	//EXTI_Line5中断允许
;;;196    	EXTI_GenerateSWInterrupt(EXTI_Line0); 
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       EXTI_GenerateSWInterrupt
;;;197    }
000056  bd1c              POP      {r2-r4,pc}
;;;198    
                          ENDP

                  NVIC_Configuration PROC
;;;422    *******************************************************************************/
;;;423    void NVIC_Configuration(void)
000058  b508              PUSH     {r3,lr}
;;;424    {
;;;425    	/*定义NVIC初始化结构体*/
;;;426    	NVIC_InitTypeDef NVIC_InitStructure;
;;;427    
;;;428    //	#ifdef  VECT_TAB_RAM  
;;;429    	/* Set the Vector Table base location at 0x20000000 */ 
;;;430    //	NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;431    //	#else  /* VECT_TAB_FLASH  */
;;;432    	/* Set the Vector Table base location at 0x08000000 */ 
;;;433    //	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
;;;434    //	#endif
;;;435    
;;;436    	NVIC_SetVectorTable(NVIC_VectTab_FLASH,0x0); //设定中断向量表机制0x08000000
00005a  2100              MOVS     r1,#0
00005c  f04f6000          MOV      r0,#0x8000000
000060  f7fffffe          BL       NVIC_SetVectorTable
;;;437    
;;;438    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);	
000064  f44f60e0          MOV      r0,#0x700
000068  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;439    
;;;440    	//设置串口中断
;;;441    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel | EXTI9_5_IRQChannel;	//串口中断
00006c  2037              MOVS     r0,#0x37
00006e  f88d0000          STRB     r0,[sp,#0]
;;;442    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级0级
000072  2003              MOVS     r0,#3
000074  f88d0001          STRB     r0,[sp,#1]
;;;443    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;	//从优先级4级
000078  2002              MOVS     r0,#2
00007a  f88d0002          STRB     r0,[sp,#2]
;;;444    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	 //IRQ通道使能
00007e  2001              MOVS     r0,#1
000080  f88d0003          STRB     r0,[sp,#3]
;;;445    	NVIC_Init(&NVIC_InitStructure);	
000084  4668              MOV      r0,sp
000086  f7fffffe          BL       NVIC_Init
;;;446    	
;;;447    	//设置外部中断线1
;;;448    	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQChannel; //中断通道
00008a  2007              MOVS     r0,#7
00008c  f88d0000          STRB     r0,[sp,#0]
;;;449    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =  0;  //强占优先级
000090  2000              MOVS     r0,#0
000092  f88d0001          STRB     r0,[sp,#1]
;;;450    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//次优先级
000096  f88d0002          STRB     r0,[sp,#2]
;;;451    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  //通道中断使能
00009a  2001              MOVS     r0,#1
00009c  f88d0003          STRB     r0,[sp,#3]
;;;452    	NVIC_Init(&NVIC_InitStructure);//初始化中断
0000a0  4668              MOV      r0,sp
0000a2  f7fffffe          BL       NVIC_Init
;;;453    
;;;454    		
;;;455    	//设置外部中断线0
;;;456    	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel; //中断通道
0000a6  2006              MOVS     r0,#6
0000a8  f88d0000          STRB     r0,[sp,#0]
;;;457    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =  0;  //强占优先级
0000ac  2000              MOVS     r0,#0
0000ae  f88d0001          STRB     r0,[sp,#1]
;;;458    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//次优先级
0000b2  f88d0002          STRB     r0,[sp,#2]
;;;459    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  //通道中断使能
0000b6  2001              MOVS     r0,#1
0000b8  f88d0003          STRB     r0,[sp,#3]
;;;460    	NVIC_Init(&NVIC_InitStructure);//初始化中断
0000bc  4668              MOV      r0,sp
0000be  f7fffffe          BL       NVIC_Init
;;;461    
;;;462    	//定时器TIM2中断
;;;463    	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQChannel;//TIM2中断
0000c2  201c              MOVS     r0,#0x1c
0000c4  f88d0000          STRB     r0,[sp,#0]
;;;464    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级0级
0000c8  2000              MOVS     r0,#0
0000ca  f88d0001          STRB     r0,[sp,#1]
;;;465    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;	//从优先级4级
0000ce  2004              MOVS     r0,#4
0000d0  f88d0002          STRB     r0,[sp,#2]
;;;466    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	 //IRQ通道使能
0000d4  2001              MOVS     r0,#1
0000d6  f88d0003          STRB     r0,[sp,#3]
;;;467    	NVIC_Init(&NVIC_InitStructure);
0000da  4668              MOV      r0,sp
0000dc  f7fffffe          BL       NVIC_Init
;;;468    	
;;;469    	//Enable the RTC Interrupt 
;;;470    	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;
0000e0  2003              MOVS     r0,#3
0000e2  f88d0000          STRB     r0,[sp,#0]
;;;471    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
0000e6  2001              MOVS     r0,#1
0000e8  f88d0001          STRB     r0,[sp,#1]
;;;472    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000ec  2000              MOVS     r0,#0
0000ee  f88d0002          STRB     r0,[sp,#2]
;;;473    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000f2  2001              MOVS     r0,#1
0000f4  f88d0003          STRB     r0,[sp,#3]
;;;474    	NVIC_Init(&NVIC_InitStructure);	
0000f8  4668              MOV      r0,sp
0000fa  f7fffffe          BL       NVIC_Init
;;;475    }
0000fe  bd08              POP      {r3,pc}
;;;476    
                          ENDP

                  TIMER_Configuration PROC
;;;391    *******************************************************************************/
;;;392    void TIMER_Configuration(void)
000100  b50e              PUSH     {r1-r3,lr}
;;;393    {
;;;394    	/*定义定时器初始化结构体*/
;;;395    	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;396    
;;;397    	TIM_DeInit(TIM2);//将Timer设置为缺省值
000102  f04f4080          MOV      r0,#0x40000000
000106  f7fffffe          BL       TIM_DeInit
;;;398    
;;;399    	TIM_InternalClockConfig(TIM2);//采用内部时钟给TIM2提供时钟源
00010a  f04f4080          MOV      r0,#0x40000000
00010e  f7fffffe          BL       TIM_InternalClockConfig
;;;400    
;;;401    	/*初始化定时器*/
;;;402    	TIM_TimeBaseStructure.TIM_Period = 10;//设置计数溢出大小，每计10个产生一个更新事件	 //自动重装周期10*0.5ms=5ms
000112  200a              MOVS     r0,#0xa
000114  f8ad0004          STRH     r0,[sp,#4]
;;;403    	TIM_TimeBaseStructure.TIM_Prescaler = 36000-1;//7199;//预分频计数值为36000-1，这样计数器时钟为72MHz/36000=2000Hz
000118  f648409f          MOV      r0,#0x8c9f
00011c  f8ad0000          STRH     r0,[sp,#0]
;;;404    	TIM_TimeBaseStructure.TIM_ClockDivision = 0;  //TIM_CKD_DIV1;设置时钟分割
000120  2000              MOVS     r0,#0
000122  f8ad0006          STRH     r0,[sp,#6]
;;;405    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数
000126  f8ad0002          STRH     r0,[sp,#2]
;;;406    	TIM_TimeBaseInit(TIM2,&TIM_TimeBaseStructure);
00012a  4669              MOV      r1,sp
00012c  f04f4080          MOV      r0,#0x40000000
000130  f7fffffe          BL       TIM_TimeBaseInit
;;;407    	TIM_ClearFlag(TIM2,TIM_FLAG_Update);//清除标志
000134  2101              MOVS     r1,#1
000136  0788              LSLS     r0,r1,#30
000138  f7fffffe          BL       TIM_ClearFlag
;;;408    	
;;;409    	TIM_ARRPreloadConfig(TIM2,DISABLE);//预装载寄存器的内容立即传送到影子寄存器
00013c  2100              MOVS     r1,#0
00013e  f04f4080          MOV      r0,#0x40000000
000142  f7fffffe          BL       TIM_ARRPreloadConfig
;;;410    
;;;411    	TIM_ITConfig(TIM2,TIM_IT_Update | TIM_IT_Trigger, ENABLE);//使能指定的TIM中断
000146  2201              MOVS     r2,#1
000148  2141              MOVS     r1,#0x41
00014a  0788              LSLS     r0,r1,#30
00014c  f7fffffe          BL       TIM_ITConfig
;;;412    
;;;413    	TIM_Cmd(TIM2,ENABLE);//开启定时器2
000150  2101              MOVS     r1,#1
000152  0788              LSLS     r0,r1,#30
000154  f7fffffe          BL       TIM_Cmd
;;;414    } 
000158  bd0e              POP      {r1-r3,pc}
;;;415    
                          ENDP

                  USART_Configuration PROC
;;;336    *******************************************************************************/
;;;337    void USART_Configuration(void)
00015a  b500              PUSH     {lr}
;;;338    {
00015c  b087              SUB      sp,sp,#0x1c
;;;339    	/* 定义 USART 初始化结构体 USART_InitStructure */
;;;340      	USART_InitTypeDef USART_InitStructure;
;;;341    
;;;342    	/*定义USART时钟结构体*/
;;;343    	USART_ClockInitTypeDef USART_ClockInitStructure;
;;;344    
;;;345    	/*	波特率为9600bps;
;;;346    	*	8位数据长度;
;;;347    	*	1个停止位，无校验;
;;;348    	*	禁用硬件流控制;
;;;349    	*	禁止USART时钟;
;;;350    	*	时钟极性低;
;;;351    	*	在第2个边沿捕获数据
;;;352    	*	最后一位数据的时钟脉冲不从 SCLK 输出； 
;;;353    	*/
;;;354    	USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
00015e  2000              MOVS     r0,#0
000160  f8ad0004          STRH     r0,[sp,#4]
;;;355    	USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
000164  f8ad0006          STRH     r0,[sp,#6]
;;;356    	USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000168  f44f7000          MOV      r0,#0x200
00016c  f8ad0008          STRH     r0,[sp,#8]
;;;357    	USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
000170  2000              MOVS     r0,#0
000172  f8ad000a          STRH     r0,[sp,#0xa]
;;;358    //	USART_ClockInit(USART2,&USART_ClockInitStructure);
;;;359    
;;;360    	USART_InitStructure.USART_BaudRate = 9600;//115200;38400
000176  f44f5016          MOV      r0,#0x2580
00017a  9003              STR      r0,[sp,#0xc]
;;;361    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00017c  2000              MOVS     r0,#0
00017e  f8ad0010          STRH     r0,[sp,#0x10]
;;;362    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000182  f8ad0012          STRH     r0,[sp,#0x12]
;;;363    	USART_InitStructure.USART_Parity = USART_Parity_No;
000186  f8ad0014          STRH     r0,[sp,#0x14]
;;;364    	USART_InitStructure.USART_HardwareFlowControl =  USART_HardwareFlowControl_None;
00018a  f8ad0018          STRH     r0,[sp,#0x18]
;;;365    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00018e  200c              MOVS     r0,#0xc
000190  f8ad0016          STRH     r0,[sp,#0x16]
;;;366    	
;;;367        USART_Init(USART2 , &USART_InitStructure);//初始化串口
000194  a903              ADD      r1,sp,#0xc
000196  48a4              LDR      r0,|L1.1064|
000198  f7fffffe          BL       USART_Init
;;;368    
;;;369      	/* 使能USART2接受中断*/
;;;370        USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);
00019c  2201              MOVS     r2,#1
00019e  f2405125          MOV      r1,#0x525
0001a2  48a1              LDR      r0,|L1.1064|
0001a4  f7fffffe          BL       USART_ITConfig
;;;371    
;;;372    	/* 使能 USART2 */
;;;373      	USART_Cmd(USART2,ENABLE); //
0001a8  2101              MOVS     r1,#1
0001aa  489f              LDR      r0,|L1.1064|
0001ac  f7fffffe          BL       USART_Cmd
;;;374    }
0001b0  b007              ADD      sp,sp,#0x1c
0001b2  bd00              POP      {pc}
;;;375    
                          ENDP

                  GPIO_Configuration PROC
;;;269    
;;;270    void GPIO_Configuration(void)
0001b4  b508              PUSH     {r3,lr}
;;;271    {
;;;272    	/* 定义 GPIO 初始化结构体 GPIO_InitStructure */
;;;273      	GPIO_InitTypeDef GPIO_InitStructure;
;;;274    	
;;;275    
;;;276    	/* 设置普通GPIO引脚（PB.12,PB.13,PB.14,PB.15）为输出引脚*/
;;;277    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;	//开关量输出4，3，2，1
0001b6  f44f4070          MOV      r0,#0xf000
0001ba  f8ad0000          STRH     r0,[sp,#0]
;;;278    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0001be  2010              MOVS     r0,#0x10
0001c0  f88d0003          STRB     r0,[sp,#3]
;;;279    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001c4  2003              MOVS     r0,#3
0001c6  f88d0002          STRB     r0,[sp,#2]
;;;280    	GPIO_Init(GPIOB , &GPIO_InitStructure);
0001ca  4669              MOV      r1,sp
0001cc  4897              LDR      r0,|L1.1068|
0001ce  f7fffffe          BL       GPIO_Init
;;;281        GPIO_SetBits(GPIOB,GPIO_Pin_15);
0001d2  f44f4100          MOV      r1,#0x8000
0001d6  4895              LDR      r0,|L1.1068|
0001d8  f7fffffe          BL       GPIO_SetBits
;;;282    	GPIO_SetBits(GPIOB,GPIO_Pin_14);
0001dc  f44f4180          MOV      r1,#0x4000
0001e0  4892              LDR      r0,|L1.1068|
0001e2  f7fffffe          BL       GPIO_SetBits
;;;283    	GPIO_SetBits(GPIOB,GPIO_Pin_13);
0001e6  f44f5100          MOV      r1,#0x2000
0001ea  4890              LDR      r0,|L1.1068|
0001ec  f7fffffe          BL       GPIO_SetBits
;;;284    	GPIO_SetBits(GPIOB,GPIO_Pin_12);
0001f0  f44f5180          MOV      r1,#0x1000
0001f4  488d              LDR      r0,|L1.1068|
0001f6  f7fffffe          BL       GPIO_SetBits
;;;285    
;;;286    
;;;287    	/* 设置普通GPIO引脚（PG.6,PG.7,PG.8）为输入引脚*/
;;;288    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8;	  //开关量输入4，3，2
0001fa  f44f70e0          MOV      r0,#0x1c0
0001fe  f8ad0000          STRH     r0,[sp,#0]
;;;289    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000202  2004              MOVS     r0,#4
000204  f88d0003          STRB     r0,[sp,#3]
;;;290    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000208  2003              MOVS     r0,#3
00020a  f88d0002          STRB     r0,[sp,#2]
;;;291    	GPIO_Init(GPIOG , &GPIO_InitStructure);
00020e  4669              MOV      r1,sp
000210  4887              LDR      r0,|L1.1072|
000212  f7fffffe          BL       GPIO_Init
;;;292    
;;;293    
;;;294    	/* 设置普通GPIO引脚（PA.8）为输入引脚*/
;;;295    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
000216  f44f7080          MOV      r0,#0x100
00021a  f8ad0000          STRH     r0,[sp,#0]
;;;296    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	//开关量输入1
00021e  2004              MOVS     r0,#4
000220  f88d0003          STRB     r0,[sp,#3]
;;;297    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000224  2003              MOVS     r0,#3
000226  f88d0002          STRB     r0,[sp,#2]
;;;298    	GPIO_Init(GPIOA , &GPIO_InitStructure);
00022a  4669              MOV      r1,sp
00022c  4881              LDR      r0,|L1.1076|
00022e  f7fffffe          BL       GPIO_Init
;;;299    
;;;300    	/* 设置普通GPIO引脚（PF.8,PF.10）为输出引脚*/
;;;301    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8|GPIO_Pin_10;	//PF.8蜂鸣器，PF.10报警灯
000232  f44f60a0          MOV      r0,#0x500
000236  f8ad0000          STRH     r0,[sp,#0]
;;;302    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00023a  2010              MOVS     r0,#0x10
00023c  f88d0003          STRB     r0,[sp,#3]
;;;303    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000240  2003              MOVS     r0,#3
000242  f88d0002          STRB     r0,[sp,#2]
;;;304    	GPIO_Init(GPIOF , &GPIO_InitStructure);
000246  4669              MOV      r1,sp
000248  487b              LDR      r0,|L1.1080|
00024a  f7fffffe          BL       GPIO_Init
;;;305    
;;;306    	/* 设置 USART2 的Tx脚（PA.2）为第二功能推挽输出功能 */
;;;307      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
00024e  2004              MOVS     r0,#4
000250  f8ad0000          STRH     r0,[sp,#0]
;;;308      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000254  2018              MOVS     r0,#0x18
000256  f88d0003          STRB     r0,[sp,#3]
;;;309      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00025a  2003              MOVS     r0,#3
00025c  f88d0002          STRB     r0,[sp,#2]
;;;310      	GPIO_Init(GPIOA , &GPIO_InitStructure);
000260  4669              MOV      r1,sp
000262  4874              LDR      r0,|L1.1076|
000264  f7fffffe          BL       GPIO_Init
;;;311        
;;;312      	/* 设置 USART2 的Rx脚（PA.3）为浮空输入脚 */
;;;313      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
000268  2008              MOVS     r0,#8
00026a  f8ad0000          STRH     r0,[sp,#0]
;;;314    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00026e  2003              MOVS     r0,#3
000270  f88d0002          STRB     r0,[sp,#2]
;;;315      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000274  2004              MOVS     r0,#4
000276  f88d0003          STRB     r0,[sp,#3]
;;;316      	GPIO_Init(GPIOA , &GPIO_InitStructure);
00027a  4669              MOV      r1,sp
00027c  486d              LDR      r0,|L1.1076|
00027e  f7fffffe          BL       GPIO_Init
;;;317    
;;;318    	//外部中断线GPIOG5
;;;319    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000282  2020              MOVS     r0,#0x20
000284  f8ad0000          STRH     r0,[sp,#0]
;;;320    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	  //配置浮空输入
000288  2004              MOVS     r0,#4
00028a  f88d0003          STRB     r0,[sp,#3]
;;;321    	GPIO_Init(GPIOG, &GPIO_InitStructure);
00028e  4669              MOV      r1,sp
000290  4867              LDR      r0,|L1.1072|
000292  f7fffffe          BL       GPIO_Init
;;;322    
;;;323    	//外部中断线GPIOG3
;;;324    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
000296  2008              MOVS     r0,#8
000298  f8ad0000          STRH     r0,[sp,#0]
;;;325    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	  //配置浮空输入
00029c  2004              MOVS     r0,#4
00029e  f88d0003          STRB     r0,[sp,#3]
;;;326    	GPIO_Init(GPIOG, &GPIO_InitStructure);
0002a2  4669              MOV      r1,sp
0002a4  4862              LDR      r0,|L1.1072|
0002a6  f7fffffe          BL       GPIO_Init
;;;327    
;;;328    }
0002aa  bd08              POP      {r3,pc}
;;;329    
                          ENDP

                  RCC_Configuration PROC
;;;205    *******************************************************************************/
;;;206    void RCC_Configuration(void)
0002ac  b510              PUSH     {r4,lr}
;;;207    {
;;;208    	/* 定义枚举类型变量 HSEStartUpStatus */
;;;209    	ErrorStatus HSEStartUpStatus;
;;;210    
;;;211      	/* 复位系统时钟设置 */
;;;212      	RCC_DeInit();
0002ae  f7fffffe          BL       RCC_DeInit
;;;213      	/* 开启 HSE */
;;;214      	RCC_HSEConfig(RCC_HSE_ON);
0002b2  f44f3080          MOV      r0,#0x10000
0002b6  f7fffffe          BL       RCC_HSEConfig
;;;215      	/* 等待 HSE 起振并稳定 */
;;;216      	HSEStartUpStatus = RCC_WaitForHSEStartUp();
0002ba  f7fffffe          BL       RCC_WaitForHSEStartUp
0002be  4604              MOV      r4,r0
;;;217    	/* 判断 HSE 起是否振成功，是则进入if()内部 */
;;;218      	if(HSEStartUpStatus == SUCCESS)
0002c0  2c01              CMP      r4,#1
0002c2  d124              BNE      |L1.782|
;;;219      	{
;;;220        	/* 选择 HCLK（AHB）时钟源为SYSCLK 1分频 */
;;;221        	RCC_HCLKConfig(RCC_SYSCLK_Div1);//配置AHB时钟=SYSCLK=72MHz
0002c4  2000              MOVS     r0,#0
0002c6  f7fffffe          BL       RCC_HCLKConfig
;;;222    
;;;223        	/* 选择 PCLK2 时钟源为 HCLK（AHB）1分频 */
;;;224        	RCC_PCLK2Config(RCC_HCLK_Div1); //配置APB2时钟=SYSCLK=72MHz
0002ca  2000              MOVS     r0,#0
0002cc  f7fffffe          BL       RCC_PCLK2Config
;;;225    
;;;226        	/* 选择 PCLK1 时钟源为 HCLK（AHB）2分频 */
;;;227        	RCC_PCLK1Config(RCC_HCLK_Div2);	//配置APB1时钟=SYSCLK/2=36MHZ，APB1的预分频系数为2 
0002d0  02a0              LSLS     r0,r4,#10
0002d2  f7fffffe          BL       RCC_PCLK1Config
;;;228    
;;;229        	/* 设置 FLASH 延时周期数为2 */
;;;230        	FLASH_SetLatency(FLASH_Latency_2);
0002d6  2002              MOVS     r0,#2
0002d8  f7fffffe          BL       FLASH_SetLatency
;;;231    
;;;232        	/* 使能 FLASH 预取缓存 */
;;;233        	FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
0002dc  2010              MOVS     r0,#0x10
0002de  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;234    
;;;235        	/* 选择锁相环（PLL）时钟源为 HSE 1分频，倍频数为9，则PLL输出频率为 8MHz * 9 = 72MHz */
;;;236        	RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
0002e2  f44f11e0          MOV      r1,#0x1c0000
0002e6  0420              LSLS     r0,r4,#16
0002e8  f7fffffe          BL       RCC_PLLConfig
;;;237    
;;;238        	/* 使能 PLL */ 
;;;239        	RCC_PLLCmd(ENABLE);
0002ec  2001              MOVS     r0,#1
0002ee  f7fffffe          BL       RCC_PLLCmd
;;;240    
;;;241        	/* 等待 PLL 输出稳定 */
;;;242        	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
0002f2  bf00              NOP      
                  |L1.756|
0002f4  2039              MOVS     r0,#0x39
0002f6  f7fffffe          BL       RCC_GetFlagStatus
0002fa  2800              CMP      r0,#0
0002fc  d0fa              BEQ      |L1.756|
;;;243    
;;;244        	/* 选择 SYSCLK 时钟源为 PLL */
;;;245        	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);//SYSCLK=PLL时钟
0002fe  2002              MOVS     r0,#2
000300  f7fffffe          BL       RCC_SYSCLKConfig
;;;246    
;;;247        	/* 等待 PLL 成为 SYSCLK 时钟源 */
;;;248        	while(RCC_GetSYSCLKSource() != 0x08);
000304  bf00              NOP      
                  |L1.774|
000306  f7fffffe          BL       RCC_GetSYSCLKSource
00030a  2808              CMP      r0,#8
00030c  d1fb              BNE      |L1.774|
                  |L1.782|
;;;249      	}
;;;250    
;;;251      	/* 使能各个用到的外设时钟 */
;;;252    	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB| RCC_APB2Periph_GPIOD | 
00030e  2101              MOVS     r1,#1
000310  f24010ed          MOV      r0,#0x1ed
000314  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;253    							RCC_APB2Periph_GPIOG| RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF|
;;;254    						    RCC_APB2Periph_AFIO,ENABLE);	//使能GPIOA，GPIOB，
;;;255    	RCC_APB1PeriphClockCmd( RCC_APB1Periph_USART2,ENABLE);  //使能串口2
000318  2101              MOVS     r1,#1
00031a  0448              LSLS     r0,r1,#17
00031c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;256    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);      //使能FSMC时钟
000320  2101              MOVS     r1,#1
000322  0208              LSLS     r0,r1,#8
000324  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;257        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);    //使能TIM2时钟
000328  2101              MOVS     r1,#1
00032a  4608              MOV      r0,r1
00032c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;258    
;;;259    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);//使能PWR和BKP时钟
000330  2101              MOVS     r1,#1
000332  f04f50c0          MOV      r0,#0x18000000
000336  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;260    }
00033a  bd10              POP      {r4,pc}
;;;261    
                          ENDP

                  main PROC
;;;52     
;;;53     int main(void)
00033c  f2405125          MOV      r1,#0x525
;;;54     {
;;;55     	USART_ClearITPendingBit(USART2,USART_IT_RXNE);
000340  4839              LDR      r0,|L1.1064|
000342  f7fffffe          BL       USART_ClearITPendingBit
;;;56     
;;;57       	/* 设置系统时钟 */
;;;58       	RCC_Configuration();
000346  f7fffffe          BL       RCC_Configuration
;;;59     
;;;60       	/* 设置 GPIO 端口 */
;;;61       	GPIO_Configuration();
00034a  f7fffffe          BL       GPIO_Configuration
;;;62     	
;;;63     	//设置FSMC
;;;64     	FSMC_CPLD_SRAM_Init();											   
00034e  f7fffffe          BL       FSMC_CPLD_SRAM_Init
;;;65        
;;;66        	/* 设置 USART */
;;;67     	USART_Configuration();
000352  f7fffffe          BL       USART_Configuration
;;;68     
;;;69     	/* 设置 TIM2*/
;;;70        	TIMER_Configuration();
000356  f7fffffe          BL       TIMER_Configuration
;;;71     
;;;72     	/*设置 中断*/
;;;73     	NVIC_Configuration();
00035a  f7fffffe          BL       NVIC_Configuration
;;;74     
;;;75      	/*配置外部中断*/
;;;76     	EXTI_Configuration();
00035e  f7fffffe          BL       EXTI_Configuration
;;;77     
;;;78     	if(BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)//如果备份寄存器中的数据错误，或者第一次执行该代码
000362  2004              MOVS     r0,#4
000364  f7fffffe          BL       BKP_ReadBackupRegister
000368  f5a04125          SUB      r1,r0,#0xa500
00036c  39a5              SUBS     r1,r1,#0xa5
00036e  d009              BEQ      |L1.900|
;;;79     	{
;;;80     		RTC_Configuration();//配置RTC
000370  f7fffffe          BL       RTC_Configuration
;;;81     		Time_Adjust();	    //调整RTC时钟数值
000374  f7fffffe          BL       Time_Adjust
;;;82     		BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);//向备份寄存器中写入0xA5A5
000378  f24a51a5          MOV      r1,#0xa5a5
00037c  2004              MOVS     r0,#4
00037e  f7fffffe          BL       BKP_WriteBackupRegister
000382  e00e              B        |L1.930|
                  |L1.900|
;;;83     	}
;;;84     	else
;;;85     	{
;;;86     		if(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)//检查POR/PDR复位状态
000384  207b              MOVS     r0,#0x7b
000386  f7fffffe          BL       RCC_GetFlagStatus
00038a  b910              CBNZ     r0,|L1.914|
;;;87     		{ 
;;;88     			//系统电源发生错误
;;;89     		}
;;;90     		else if(RCC_GetFlagStatus(RCC_FLAG_PINRST)!=RESET)
00038c  207a              MOVS     r0,#0x7a
00038e  f7fffffe          BL       RCC_GetFlagStatus
                  |L1.914|
;;;91     		{
;;;92     			//外部复位
;;;93     		}		
;;;94     		RTC_WaitForSynchro();//等待RTC同步成功
000392  f7fffffe          BL       RTC_WaitForSynchro
;;;95     		RTC_ITConfig(RTC_IT_SEC, ENABLE);//使能RTC秒中断
000396  2101              MOVS     r1,#1
000398  4608              MOV      r0,r1
00039a  f7fffffe          BL       RTC_ITConfig
;;;96     		RTC_WaitForLastTask();//等待上一次对RTC寄存器写操作成功
00039e  f7fffffe          BL       RTC_WaitForLastTask
                  |L1.930|
;;;97     	}	
;;;98      
;;;99     	RCC_ClearFlag(); //清除复位标志
0003a2  f7fffffe          BL       RCC_ClearFlag
;;;100    	
;;;101    
;;;102    
;;;103        /*设置 开关量输出   
;;;104    	GPIO_SetBits(GPIOB,GPIO_Pin_12);
;;;105    	GPIO_ResetBits(GPIOB,GPIO_Pin_13);
;;;106    	GPIO_ResetBits(GPIOB,GPIO_Pin_14);
;;;107    	GPIO_ResetBits(GPIOB,GPIO_Pin_15);	 
;;;108    	*/
;;;109    
;;;110    	while(1)
0003a6  e01e              B        |L1.998|
                  |L1.936|
;;;111    	{
;;;112    		//IO测试
;;;113    	 	/*state1 =   GPIO_ReadInputDataBit(GPIOG,GPIO_Pin_6);  
;;;114    		state2 =   GPIO_ReadInputDataBit(GPIOG,GPIO_Pin_7);  
;;;115    		state3 =   GPIO_ReadInputDataBit(GPIOG,GPIO_Pin_8);  
;;;116    		state4 =   GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_8);  
;;;117    
;;;118            if (state1==0x00) GPIO_ResetBits(GPIOB,GPIO_Pin_15);//读取指定端口位
;;;119    		   else 		  GPIO_SetBits(GPIOB,GPIO_Pin_15);
;;;120    	    if (state2==0x00) GPIO_ResetBits(GPIOB,GPIO_Pin_14);//读取指定端口位
;;;121    		   else 		  GPIO_SetBits(GPIOB,GPIO_Pin_14);
;;;122          	if (state3==0x00) GPIO_ResetBits(GPIOB,GPIO_Pin_13);//读取指定端口位
;;;123    	       else 		  GPIO_SetBits(GPIOB,GPIO_Pin_13);
;;;124    	    if (state4==0x00) GPIO_ResetBits(GPIOB,GPIO_Pin_12);//读取指定端口位
;;;125    		   else 		  GPIO_SetBits(GPIOB,GPIO_Pin_12);	*/
;;;126    
;;;127    		//RS232测试
;;;128    		USART_SendData(USART2,0x11);
0003a8  2111              MOVS     r1,#0x11
0003aa  481f              LDR      r0,|L1.1064|
0003ac  f7fffffe          BL       USART_SendData
;;;129    
;;;130    		//rdata = USART_ReceiveData(USART2);
;;;131    		//printf("%x,%.4f\r\n",0xC0,11111);
;;;132            /*switch(RxFlagUSART2)
;;;133    		{
;;;134    			case 5: printf("%x,%.4f\r\n",0xC3,ADValueChannel);break;
;;;135    			default:break;
;;;136    		}
;;;137    		RxFlag = 0;	//清除发送标志位等待接受下次的指令值
;;;138    	    Delay_ms(1000);	*/
;;;139    	  
;;;140    	  	//FSMC测试
;;;141    		*(vu16*) (0x60000004) = 0x5555;
0003b0  f2455055          MOV      r0,#0x5555
0003b4  f04f41c0          MOV      r1,#0x60000000
0003b8  8088              STRH     r0,[r1,#4]
;;;142    		Buffer1	= *(vu16*) (0x60000004);
0003ba  4608              MOV      r0,r1
0003bc  8880              LDRH     r0,[r0,#4]
0003be  491f              LDR      r1,|L1.1084|
0003c0  8008              STRH     r0,[r1,#0]
;;;143    
;;;144    		//*(vu16*) (0x68000003) = 0x5555;
;;;145    		//Buffer2	= *(vu16*) (0x68000000);
;;;146    
;;;147    		//TxBuffer[0] = 0x1123;
;;;148    		//FSMC_CPLD_SRAM_WriteBuffer(TxBuffer, WRITE_READ_ADDR, BUFFER_SIZE);
;;;149    		//FSMC_CPLD_SRAM_ReadBuffer(RxBuffer, WRITE_READ_ADDR, BUFFER_SIZE); 
;;;150    
;;;151    		//Buffer2 = *(vu16*) (0x68000000);
;;;152    
;;;153    		//得到时间
;;;154    		Time_Display(RTC_GetCounter());
0003c2  f7fffffe          BL       RTC_GetCounter
0003c6  4604              MOV      r4,r0
0003c8  f7fffffe          BL       Time_Display
;;;155    
;;;156    		//Flash操作测试
;;;157    		Write_To_Flash[0] = 0x78;
0003cc  2078              MOVS     r0,#0x78
0003ce  491c              LDR      r1,|L1.1088|
0003d0  6008              STR      r0,[r1,#0]  ; Write_To_Flash
;;;158    		WriteFlashOneWord(0x00,Write_To_Flash[0]);
0003d2  4608              MOV      r0,r1
0003d4  6801              LDR      r1,[r0,#0]  ; Write_To_Flash
0003d6  2000              MOVS     r0,#0
0003d8  f7fffffe          BL       WriteFlashOneWord
;;;159    		ReadFlashNByte(0x00,Read_From_Flash,1);
0003dc  2201              MOVS     r2,#1
0003de  4919              LDR      r1,|L1.1092|
0003e0  2000              MOVS     r0,#0
0003e2  f7fffffe          BL       ReadFlashNByte
                  |L1.998|
0003e6  e7df              B        |L1.936|
;;;160    	}
;;;161    }  				 
;;;162    
                          ENDP

                  fputc PROC
;;;484    																		    
;;;485    int fputc(int ch, FILE *f)
0003e8  b570              PUSH     {r4-r6,lr}
;;;486    {
0003ea  4604              MOV      r4,r0
0003ec  460d              MOV      r5,r1
;;;487    	USART_SendData(USART2, (u8) ch); //
0003ee  b2e1              UXTB     r1,r4
0003f0  480d              LDR      r0,|L1.1064|
0003f2  f7fffffe          BL       USART_SendData
;;;488    	while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);	 //
0003f6  bf00              NOP      
                  |L1.1016|
0003f8  2140              MOVS     r1,#0x40
0003fa  480b              LDR      r0,|L1.1064|
0003fc  f7fffffe          BL       USART_GetFlagStatus
000400  2800              CMP      r0,#0
000402  d0f9              BEQ      |L1.1016|
;;;489    	return ch;
000404  4620              MOV      r0,r4
;;;490    }
000406  bd70              POP      {r4-r6,pc}
;;;491    /*******************************************************************************
                          ENDP

                  Delay_ms PROC
;;;497    *******************************************************************************/
;;;498    void Delay_ms(u16 time)
000408  2100              MOVS     r1,#0
;;;499    {
;;;500    	u16 i = 0;
;;;501    	while(time--)
00040a  e006              B        |L1.1050|
                  |L1.1036|
;;;502    	{
;;;503    		i = 120;
00040c  2178              MOVS     r1,#0x78
;;;504    		while(i--);
00040e  bf00              NOP      
                  |L1.1040|
000410  000a              MOVS     r2,r1
000412  f1a10301          SUB      r3,r1,#1
000416  b299              UXTH     r1,r3
000418  d1fa              BNE      |L1.1040|
                  |L1.1050|
00041a  0002              MOVS     r2,r0                 ;501
00041c  f1a00301          SUB      r3,r0,#1              ;501
000420  b298              UXTH     r0,r3                 ;501
000422  d1f3              BNE      |L1.1036|
;;;505    	}
;;;506    }
000424  4770              BX       lr
                          ENDP

000426  0000              DCW      0x0000
                  |L1.1064|
                          DCD      0x40004400
                  |L1.1068|
                          DCD      0x40010c00
                  |L1.1072|
                          DCD      0x40012000
                  |L1.1076|
                          DCD      0x40010800
                  |L1.1080|
                          DCD      0x40011c00
                  |L1.1084|
                          DCD      Buffer1
                  |L1.1088|
                          DCD      Write_To_Flash
                  |L1.1092|
                          DCD      Read_From_Flash

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Write_To_Flash
                          %        20
                  Read_From_Flash
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  RxFlagUSART2
000000  00                DCB      0x00
                  RxFlag
000001  00                DCB      0x00
                  state1
000002  00                DCB      0x00
                  state2
000003  00                DCB      0x00
                  state3
000004  00                DCB      0x00
                  state4
000005  00                DCB      0x00
                  rdata
000006  0000              DCB      0x00,0x00
                  THH
                          DCD      0x00000000
                  TMM
                          DCD      0x00000000
                  TSS
                          DCD      0x00000000
                  TxBuffer
                          DCD      0x00000000
                  RxBuffer
                          DCD      0x00000000
                  Buffer1
00001c  0000              DCB      0x00,0x00
                  Buffer2
00001e  0000              DCB      0x00,0x00

                  __ARM_use_no_argv EQU 0
