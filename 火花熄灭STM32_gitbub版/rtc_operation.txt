; generated by ARM C/C++ Compiler, 4.1 [Build 567]
; commandline ArmCC [--list --debug -c --asm --interleave -ortc_operation.o --asm_dir=.\ --list_dir=.\ --depend=rtc_operation.d --cpu=Cortex-M3 --apcs=interwork -O0 -I"E:\Program Files\Keil4\ARM\INC" -I"E:\Program Files\Keil4\ARM\INC\ST\STM32F10x" -D__MICROLIB --omf_browse=rtc_operation.crf User\Rtc_operation.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_Configuration PROC
;;;14     *******************************************************************************/
;;;15     void RTC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;16     { 
;;;17       //启用PWR和BKP的时钟（from APB1）
;;;18       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000002  2101              MOVS     r1,#1
000004  f04f50c0          MOV      r0,#0x18000000
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;19     
;;;20       //后备域解锁
;;;21       PWR_BackupAccessCmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;22     
;;;23       //备份寄存器模块复位
;;;24       BKP_DeInit();
000012  f7fffffe          BL       BKP_DeInit
;;;25     
;;;26       /* Enable LSE */
;;;27       RCC_LSEConfig(RCC_LSE_ON);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       RCC_LSEConfig
;;;28      
;;;29       //等待稳定
;;;30       while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
00001c  bf00              NOP      
                  |L1.30|
00001e  2041              MOVS     r0,#0x41
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0fa              BEQ      |L1.30|
;;;31       {}
;;;32       //RTC时钟源配置成LSE（外部32.768K）
;;;33       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000028  f44f7080          MOV      r0,#0x100
00002c  f7fffffe          BL       RCC_RTCCLKConfig
;;;34     
;;;35       //RTC开启
;;;36       RCC_RTCCLKCmd(ENABLE);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       RCC_RTCCLKCmd
;;;37     
;;;38       //开启后需要等待APB1时钟与RTC时钟同步，才能读写寄存器
;;;39       RTC_WaitForSynchro();
000036  f7fffffe          BL       RTC_WaitForSynchro
;;;40     
;;;41       //读写寄存器前，要确定上一个操作已经结束
;;;42       RTC_WaitForLastTask();
00003a  f7fffffe          BL       RTC_WaitForLastTask
;;;43       
;;;44       //使能秒中断
;;;45       RTC_ITConfig(RTC_IT_SEC, ENABLE);   
00003e  2101              MOVS     r1,#1
000040  4608              MOV      r0,r1
000042  f7fffffe          BL       RTC_ITConfig
;;;46     
;;;47       //读写寄存器前，要确定上一个操作已经结束
;;;48       RTC_WaitForLastTask();
000046  f7fffffe          BL       RTC_WaitForLastTask
;;;49     
;;;50       //设置RTC分频器，使RTC时钟为1Hz
;;;51       //RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1)
;;;52       RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
00004a  f64770ff          MOV      r0,#0x7fff
00004e  f7fffffe          BL       RTC_SetPrescaler
;;;53     
;;;54       //等待寄存器写入完成
;;;55       RTC_WaitForLastTask();
000052  f7fffffe          BL       RTC_WaitForLastTask
;;;56     }
000056  bd10              POP      {r4,pc}
;;;57     
                          ENDP

                  Is_Leap_Year PROC
;;;176    
;;;177    u8 Is_Leap_Year(u16 year)
000058  4601              MOV      r1,r0
;;;178    {
;;;179    	if( ((year%4==0)&&(year%100 != 0)) || (year%400==0) )
00005a  17ca              ASRS     r2,r1,#31
00005c  eb017292          ADD      r2,r1,r2,LSR #30
000060  1092              ASRS     r2,r2,#2
000062  ebb10282          SUBS     r2,r1,r2,LSL #2
000066  d105              BNE      |L1.116|
000068  2264              MOVS     r2,#0x64
00006a  fb91f3f2          SDIV     r3,r1,r2
00006e  fb021213          MLS      r2,r2,r3,r1
000072  b932              CBNZ     r2,|L1.130|
                  |L1.116|
000074  f44f72c8          MOV      r2,#0x190
000078  fb91f3f2          SDIV     r3,r1,r2
00007c  fb021213          MLS      r2,r2,r3,r1
000080  b90a              CBNZ     r2,|L1.134|
                  |L1.130|
;;;180    		return 1;
000082  2001              MOVS     r0,#1
                  |L1.132|
;;;181    	else
;;;182    		return 0;
;;;183    }
000084  4770              BX       lr
                  |L1.134|
000086  2000              MOVS     r0,#0                 ;182
000088  e7fc              B        |L1.132|
;;;184    
                          ENDP

                  Set_Cur_Time PROC
;;;83     ******************************************************************************/
;;;84     u32 Set_Cur_Time(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)
00008a  e92d4ff0          PUSH     {r4-r11,lr}
;;;85     {
00008e  4606              MOV      r6,r0
000090  460f              MOV      r7,r1
000092  4690              MOV      r8,r2
000094  4699              MOV      r9,r3
000096  e9ddab09          LDRD     r10,r11,[sp,#0x24]
;;;86     	u16 t;
;;;87     	u32 seccount = 0;
00009a  2400              MOVS     r4,#0
;;;88     	if(syear<1970||syear>2099)//以1970年1月1日为基准，1970-2099为合法年份
00009c  f24070b2          MOV      r0,#0x7b2
0000a0  4286              CMP      r6,r0
0000a2  db03              BLT      |L1.172|
0000a4  f6400033          MOV      r0,#0x833
0000a8  4286              CMP      r6,r0
0000aa  dd02              BLE      |L1.178|
                  |L1.172|
;;;89     		return 1;
0000ac  2001              MOVS     r0,#1
                  |L1.174|
;;;90     	
;;;91     	for(t=1970;t<syear;t++)
;;;92     	{
;;;93     		if(Is_Leap_Year(t))
;;;94     			seccount += 31622400;//闰年的秒钟数
;;;95     		else
;;;96     			seccount += 31536000;//平年的秒钟数
;;;97     	}
;;;98     
;;;99     	smon -= 1;
;;;100    	for(t=0;t<smon;t++)
;;;101    	{
;;;102    		seccount += (u32)mon_table[t]*86400;//月份秒钟数相加
;;;103    		if(Is_Leap_Year(syear)&&t==1)
;;;104    			seccount += 86400;   			//闰年2月份增加一天的秒钟数
;;;105    	}
;;;106    	
;;;107    	seccount += (u32)(sday-1)*86400;		//把前面天数的秒钟相加
;;;108    	seccount += (u32)(hour)*3600;		    //小时秒钟数
;;;109    	seccount += (u32)(min)*60;				//分钟秒钟数
;;;110    	seccount += sec;						//加上最后的秒钟数
;;;111    	
;;;112    	return seccount;	
;;;113    }
0000ae  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.178|
0000b2  f24075b2          MOV      r5,#0x7b2             ;91
0000b6  e00a              B        |L1.206|
                  |L1.184|
0000b8  4628              MOV      r0,r5                 ;93
0000ba  f7fffffe          BL       Is_Leap_Year
0000be  b110              CBZ      r0,|L1.198|
0000c0  487b              LDR      r0,|L1.688|
0000c2  4404              ADD      r4,r4,r0              ;94
0000c4  e001              B        |L1.202|
                  |L1.198|
0000c6  487b              LDR      r0,|L1.692|
0000c8  4404              ADD      r4,r4,r0              ;96
                  |L1.202|
0000ca  1c68              ADDS     r0,r5,#1              ;91
0000cc  b285              UXTH     r5,r0                 ;91
                  |L1.206|
0000ce  42b5              CMP      r5,r6                 ;91
0000d0  dbf2              BLT      |L1.184|
0000d2  1e78              SUBS     r0,r7,#1              ;99
0000d4  b2c7              UXTB     r7,r0                 ;99
0000d6  2500              MOVS     r5,#0                 ;100
0000d8  e010              B        |L1.252|
                  |L1.218|
0000da  4877              LDR      r0,|L1.696|
0000dc  5d40              LDRB     r0,[r0,r5]            ;102
0000de  f24021a3          MOV      r1,#0x2a3             ;102
0000e2  4348              MULS     r0,r1,r0              ;102
0000e4  eb0414c0          ADD      r4,r4,r0,LSL #7       ;102
0000e8  4630              MOV      r0,r6                 ;103
0000ea  f7fffffe          BL       Is_Leap_Year
0000ee  b118              CBZ      r0,|L1.248|
0000f0  2d01              CMP      r5,#1                 ;103
0000f2  d101              BNE      |L1.248|
0000f4  4871              LDR      r0,|L1.700|
0000f6  4404              ADD      r4,r4,r0              ;104
                  |L1.248|
0000f8  1c68              ADDS     r0,r5,#1              ;100
0000fa  b285              UXTH     r5,r0                 ;100
                  |L1.252|
0000fc  42bd              CMP      r5,r7                 ;100
0000fe  dbec              BLT      |L1.218|
000100  f1a80001          SUB      r0,r8,#1              ;107
000104  f24021a3          MOV      r1,#0x2a3             ;107
000108  4348              MULS     r0,r1,r0              ;107
00010a  eb0414c0          ADD      r4,r4,r0,LSL #7       ;107
00010e  ebc91049          RSB      r0,r9,r9,LSL #5       ;108
000112  ebc02009          RSB      r0,r0,r9,LSL #8       ;108
000116  eb041400          ADD      r4,r4,r0,LSL #4       ;108
00011a  ebca100a          RSB      r0,r10,r10,LSL #4     ;109
00011e  eb040480          ADD      r4,r4,r0,LSL #2       ;109
000122  445c              ADD      r4,r4,r11             ;110
000124  4620              MOV      r0,r4                 ;112
000126  e7c2              B        |L1.174|
;;;114    /******************************************************************************
                          ENDP

                  Time_Adjust PROC
;;;64     *******************************************************************************/
;;;65     void Time_Adjust(void)
000128  b51c              PUSH     {r2-r4,lr}
;;;66     { 
;;;67       /* Wait until last write operation on RTC registers has finished */
;;;68       RTC_WaitForLastTask();
00012a  f7fffffe          BL       RTC_WaitForLastTask
;;;69       /* Change the current time */
;;;70       //RTC_SetCounter(2016*12*3600 + 2*60 + 0);	
;;;71       RTC_SetCounter(Set_Cur_Time(2016,4,1,7,12,0));
00012e  2300              MOVS     r3,#0
000130  220c              MOVS     r2,#0xc
000132  e9cd2300          STRD     r2,r3,[sp,#0]
000136  2307              MOVS     r3,#7
000138  2201              MOVS     r2,#1
00013a  2104              MOVS     r1,#4
00013c  f44f60fc          MOV      r0,#0x7e0
000140  f7fffffe          BL       Set_Cur_Time
000144  4604              MOV      r4,r0
000146  f7fffffe          BL       RTC_SetCounter
;;;72       /* Wait until last write operation on RTC registers has finished */
;;;73       RTC_WaitForLastTask();
00014a  f7fffffe          BL       RTC_WaitForLastTask
;;;74     }
00014e  bd1c              POP      {r2-r4,pc}
;;;75     
                          ENDP

                  Get_Cur_Time PROC
;;;120    ******************************************************************************/
;;;121    u8 Get_Cur_Time()
000150  b570              PUSH     {r4-r6,lr}
;;;122    {
;;;123    	static u16 daycnt = 0;
;;;124    	u32 timecount = 0;
000152  2600              MOVS     r6,#0
;;;125    	u32 temp = 0;
000154  2400              MOVS     r4,#0
;;;126    	u16 temp1 = 0;
000156  2500              MOVS     r5,#0
;;;127    	timecount = RTC_GetCounter();//获得计数器中的值
000158  f7fffffe          BL       RTC_GetCounter
00015c  4606              MOV      r6,r0
;;;128    
;;;129    	temp = timecount/86400;      //得到天数
00015e  4857              LDR      r0,|L1.700|
000160  fbb6f4f0          UDIV     r4,r6,r0
;;;130    	if(daycnt!=temp)			 //超过一天
000164  4856              LDR      r0,|L1.704|
000166  8800              LDRH     r0,[r0,#0]  ; daycnt
000168  42a0              CMP      r0,r4
00016a  d03a              BEQ      |L1.482|
;;;131    	{
;;;132    		daycnt = temp;
00016c  4954              LDR      r1,|L1.704|
00016e  800c              STRH     r4,[r1,#0]
;;;133    		temp1 = 1970;
000170  f24075b2          MOV      r5,#0x7b2
;;;134    		while(temp>=365)
000174  e00e              B        |L1.404|
                  |L1.374|
;;;135    		{
;;;136    			if(Is_Leap_Year(temp1))//闰年
000176  4628              MOV      r0,r5
000178  f7fffffe          BL       Is_Leap_Year
00017c  b130              CBZ      r0,|L1.396|
;;;137    			{
;;;138    				if(temp>=366) temp -= 366;
00017e  f5b47fb7          CMP      r4,#0x16e
000182  d302              BCC      |L1.394|
000184  f5a474b7          SUB      r4,r4,#0x16e
000188  e002              B        |L1.400|
                  |L1.394|
;;;139    				else break;
00018a  e006              B        |L1.410|
                  |L1.396|
;;;140    			}
;;;141    			else
;;;142    				temp -= 365;	   //平年
00018c  f2a4146d          SUB      r4,r4,#0x16d
                  |L1.400|
;;;143    			temp1++;
000190  1c68              ADDS     r0,r5,#1
000192  b285              UXTH     r5,r0
                  |L1.404|
000194  f5b47fb6          CMP      r4,#0x16c             ;134
000198  d8ed              BHI      |L1.374|
                  |L1.410|
00019a  bf00              NOP                            ;139
;;;144    		}
;;;145    		calendar.year = temp1;
00019c  4849              LDR      r0,|L1.708|
00019e  8005              STRH     r5,[r0,#0]
;;;146    
;;;147    		temp1 = 0;
0001a0  2500              MOVS     r5,#0
;;;148    		while(temp>=28)//超过一个月
0001a2  e016              B        |L1.466|
                  |L1.420|
;;;149    		{
;;;150    			if(Is_Leap_Year(calendar.year)&&temp1==1)//判断当年是否是闰年的2月份
0001a4  4947              LDR      r1,|L1.708|
0001a6  8808              LDRH     r0,[r1,#0]  ; calendar
0001a8  f7fffffe          BL       Is_Leap_Year
0001ac  b130              CBZ      r0,|L1.444|
0001ae  2d01              CMP      r5,#1
0001b0  d104              BNE      |L1.444|
;;;151    			{
;;;152    				if(temp>=29) temp-=29;
0001b2  2c1d              CMP      r4,#0x1d
0001b4  d301              BCC      |L1.442|
0001b6  3c1d              SUBS     r4,r4,#0x1d
0001b8  e009              B        |L1.462|
                  |L1.442|
;;;153    				else break;
0001ba  e00c              B        |L1.470|
                  |L1.444|
;;;154    			}
;;;155    			else
;;;156    			{
;;;157    				if(temp>=mon_table[temp1])
0001bc  483e              LDR      r0,|L1.696|
0001be  5d40              LDRB     r0,[r0,r5]
0001c0  42a0              CMP      r0,r4
0001c2  d803              BHI      |L1.460|
;;;158    					temp-=mon_table[temp1];
0001c4  483c              LDR      r0,|L1.696|
0001c6  5d40              LDRB     r0,[r0,r5]
0001c8  1a24              SUBS     r4,r4,r0
0001ca  e000              B        |L1.462|
                  |L1.460|
;;;159    				else
;;;160    					break;
0001cc  e003              B        |L1.470|
                  |L1.462|
;;;161    			}
;;;162    			temp1++;
0001ce  1c68              ADDS     r0,r5,#1
0001d0  b285              UXTH     r5,r0
                  |L1.466|
0001d2  2c1c              CMP      r4,#0x1c              ;148
0001d4  d2e6              BCS      |L1.420|
                  |L1.470|
0001d6  bf00              NOP                            ;153
;;;163    		}
;;;164    		calendar.month = temp1+1;
0001d8  1c68              ADDS     r0,r5,#1
0001da  493a              LDR      r1,|L1.708|
0001dc  7088              STRB     r0,[r1,#2]
;;;165    		calendar.data = temp+1;
0001de  1c60              ADDS     r0,r4,#1
0001e0  70c8              STRB     r0,[r1,#3]
                  |L1.482|
;;;166    	}
;;;167    	
;;;168    	temp=timecount%86400;//得到秒钟数
0001e2  4836              LDR      r0,|L1.700|
0001e4  fbb6f1f0          UDIV     r1,r6,r0
0001e8  fb006411          MLS      r4,r0,r1,r6
;;;169    	calendar.hour = temp/3600;//小时
0001ec  f44f6061          MOV      r0,#0xe10
0001f0  fbb4f0f0          UDIV     r0,r4,r0
0001f4  4933              LDR      r1,|L1.708|
0001f6  7108              STRB     r0,[r1,#4]
;;;170    	calendar.min = (temp%3600)/60;//分钟
0001f8  f44f6061          MOV      r0,#0xe10
0001fc  fbb4f1f0          UDIV     r1,r4,r0
000200  fb004011          MLS      r0,r0,r1,r4
000204  213c              MOVS     r1,#0x3c
000206  fbb0f0f1          UDIV     r0,r0,r1
00020a  492e              LDR      r1,|L1.708|
00020c  7148              STRB     r0,[r1,#5]
;;;171    	calendar.second = (temp%36000)%60;//秒钟
00020e  f64840a0          MOV      r0,#0x8ca0
000212  fbb4f1f0          UDIV     r1,r4,r0
000216  fb004011          MLS      r0,r0,r1,r4
00021a  213c              MOVS     r1,#0x3c
00021c  fbb0f2f1          UDIV     r2,r0,r1
000220  fb010012          MLS      r0,r1,r2,r0
000224  4927              LDR      r1,|L1.708|
000226  7188              STRB     r0,[r1,#6]
;;;172    
;;;173    	return 0;
000228  2000              MOVS     r0,#0
;;;174    }
00022a  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

                  Time_Regulate PROC
;;;191    ******************************************************************************/
;;;192    u32 Time_Regulate()
00022c  b510              PUSH     {r4,lr}
;;;193    {
;;;194    	int Tmp_HH = 0xFF,Tmp_MM=0xFF,Tmp_SS=0xFF;
00022e  21ff              MOVS     r1,#0xff
000230  22ff              MOVS     r2,#0xff
000232  20ff              MOVS     r0,#0xff
000234  4603              MOV      r3,r0
;;;195    
;;;196    	//从串口获取小时数
;;;197    	while(Tmp_HH==0xFF)
000236  e00e              B        |L1.598|
                  |L1.568|
;;;198    //		Tmp_HH=USART_Scanf(23);
;;;199    
;;;200    	//从串口获取分钟数
;;;201    	while(Tmp_MM==0xFF)
000238  e00b              B        |L1.594|
                  |L1.570|
;;;202    //		Tmp_MM=USART_Scanf(59);
;;;203    
;;;204    	//从串口获取秒数据
;;;205    	while(Tmp_SS==0xFF)
00023a  e008              B        |L1.590|
                  |L1.572|
;;;206    //		Tmp_SS=USART_Scanf(59);
;;;207    
;;;208    	return ((Tmp_HH*3600 + Tmp_MM*60 + Tmp_SS));
00023c  f44f6061          MOV      r0,#0xe10
000240  4348              MULS     r0,r1,r0
000242  ebc21402          RSB      r4,r2,r2,LSL #4
000246  eb000084          ADD      r0,r0,r4,LSL #2
00024a  4418              ADD      r0,r0,r3
                  |L1.588|
;;;209    }
00024c  bd10              POP      {r4,pc}
                  |L1.590|
00024e  2bff              CMP      r3,#0xff              ;205
000250  d0f4              BEQ      |L1.572|
                  |L1.594|
000252  2aff              CMP      r2,#0xff              ;201
000254  d0f1              BEQ      |L1.570|
                  |L1.598|
000256  29ff              CMP      r1,#0xff              ;197
000258  d0ee              BEQ      |L1.568|
00025a  bf00              NOP      
00025c  e7f6              B        |L1.588|
;;;210    
                          ENDP

                  Time_Display PROC
;;;211    
;;;212    void Time_Display(u32 Timevar)
00025e  b570              PUSH     {r4-r6,lr}
;;;213    {
;;;214    	u32 HH=0,MM=0,SS=0;
000260  2100              MOVS     r1,#0
000262  2200              MOVS     r2,#0
000264  2300              MOVS     r3,#0
;;;215    
;;;216    	HH = Timevar / 3600;
000266  f44f6461          MOV      r4,#0xe10
00026a  fbb0f1f4          UDIV     r1,r0,r4
;;;217    	HH = (Timevar % 3600) / 60;
00026e  fbb0f5f4          UDIV     r5,r0,r4
000272  fb040415          MLS      r4,r4,r5,r0
000276  253c              MOVS     r5,#0x3c
000278  fbb4f1f5          UDIV     r1,r4,r5
;;;218    	HH = (Timevar % 3600) % 60;
00027c  f44f6461          MOV      r4,#0xe10
000280  fbb0f5f4          UDIV     r5,r0,r4
000284  fb040415          MLS      r4,r4,r5,r0
000288  253c              MOVS     r5,#0x3c
00028a  fbb4f6f5          UDIV     r6,r4,r5
00028e  fb054116          MLS      r1,r5,r6,r4
;;;219    }
000292  bd70              POP      {r4-r6,pc}
;;;220    
                          ENDP

                  Time_Show PROC
;;;221    
;;;222    void Time_Show(void)
000294  e00b              B        |L1.686|
                  |L1.662|
;;;223    {
;;;224    	while(1)
;;;225    	{
;;;226    		if(TimeDisplay==1)
000296  480c              LDR      r0,|L1.712|
000298  7800              LDRB     r0,[r0,#0]  ; TimeDisplay
00029a  2801              CMP      r0,#1
00029c  d104              BNE      |L1.680|
;;;227    		{
;;;228    			Time_Display(RTC_GetCounter());
00029e  f7fffffe          BL       RTC_GetCounter
0002a2  4604              MOV      r4,r0
0002a4  f7fffffe          BL       Time_Display
                  |L1.680|
;;;229    		}
;;;230    		TimeDisplay = 0;
0002a8  2000              MOVS     r0,#0
0002aa  4907              LDR      r1,|L1.712|
0002ac  7008              STRB     r0,[r1,#0]
                  |L1.686|
0002ae  e7f2              B        |L1.662|
;;;231    	}
;;;232    }
;;;233    
                          ENDP

                  |L1.688|
                          DCD      0x01e28500
                  |L1.692|
                          DCD      0x01e13380
                  |L1.696|
                          DCD      mon_table
                  |L1.700|
                          DCD      0x00015180
                  |L1.704|
                          DCD      daycnt
                  |L1.708|
                          DCD      calendar
                  |L1.712|
                          DCD      TimeDisplay

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  mon_table
000000  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000004  1f1e1f1e          DCB      0x1f,0x1e,0x1f,0x1e
000008  1f1e1f1e          DCB      0x1f,0x1e,0x1f,0x1e

                          AREA ||.data||, DATA, ALIGN=1

                  daycnt
000000  0000              DCW      0x0000
